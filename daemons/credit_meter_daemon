#!/usr/bin/env python
from daemon import Daemon
from service_utils import *

FORMAT = '%(message)s'
logging.basicConfig(filename=CREDIT_LOG,level=logging.DEBUG,format=FORMAT)

class DaemonProcess(Daemon):
	
	def __init__(self,pidfile):
		Daemon.__init__(self,pidfile)
		self.clients={}
		self.locked=False
		self.locktime=0
		self.CREDIT_METER=1
		self.wms=[]
		self.wus=[]
		
		
	def while_running(self,*args):
		"""
		Manage Users and Firewall:
		"""
		url="http://%s/services/send_update_to_credit_meter"%(get_rpc_hostname())
		f=urllib2.urlopen(url)
		dummy=f.read(100)
		f.close()
		
		while self.RUNNING:
			time.sleep(TSLEEP)
			for sk in self.clients.keys():
				if time.time()-self.clients[sk]['t_last'] > CREDIT_METER_TIMEOUT:
					
					if self.clients[sk]['active']==0:continue
					
					msg="%s timeout"%(sk)
					logging.debug(msg)
					
					t_elapsed=int(time.time()-self.clients[sk]['t_start'])
					dt_last=int(time.time()-self.clients[sk]['t_last'])
					self.clients[sk]['dt_last']=dt_last
					self.clients[sk]['t_last']=time.time()
					self.clients[sk]['t_elapsed']=t_elapsed
					self.clients[sk]['active']=0
					
					rval=self.update_firewall()
					
					break
					
	def new_client(self):
		c={
			'macs':[],
			't_start':0,
			't_last':0,
			't_elapsed':0,
			'dt_last':0,
			'active':0,
			'credits':0,
		}
		return c
	
	
	def stop(self,*args):
		
		logging.debug("credit_meter_daemon.stop")
		if not args:
			Daemon.stop(self)
			return {}
		
		d=args[0]
		sk=d['sk']
		mac=d['mac']
		macs=d['macs']
		credits=d['credits']
		
		if self.clients.has_key(sk):
			t_elapsed=int(time.time()-self.clients[sk]['t_start'])
			dt_last=int(time.time()-self.clients[sk]['t_last'])
			self.clients[sk]['dt_last']=dt_last
			self.clients[sk]['t_last']=time.time()
			self.clients[sk]['t_elapsed']=t_elapsed
			self.clients[sk]['active']=0
			self.clients[sk]['credits']=credits
			
			rval=self.update_firewall()
		else:
			logging.warning("this should never happen")
		
			
		d['t_elapsed']=self.clients[sk]['t_elapsed']
		d['dt_last']=0
		
		return d
		
				
	def keepalive(self,*args):
		
		
		d=args[0]
		sk=d['session_key']
		mac=d['mac']
		macs=d['macs']
		credits=d['credits']
		
		msg="keepalive: %s"%sk
		logging.debug(msg)
		
		need_update=False
		
		if self.clients.has_key(sk):
			logging.debug("found client")
			if not self.clients[sk]['active']:
				logging.debug("activating client")
				self.clients[sk]['macs']=macs
				self.clients[sk]['t_start']=time.time()
				self.clients[sk]['t_last']=time.time()
				self.clients[sk]['t_elapsed']=0
				self.clients[sk]['dt_last']=0
				self.clients[sk]['active']=1
				
				need_update=True
				
			else:
				logging.debug("client active")	
			
			t_elapsed=int(time.time()-self.clients[sk]['t_start'])
			dt_last=int(time.time()-self.clients[sk]['t_last'])
			self.clients[sk]['dt_last']=dt_last
			self.clients[sk]['t_last']=time.time()
			self.clients[sk]['t_elapsed']=t_elapsed
			
			msg="dt_last=%d"%dt_last
			logging.debug(msg)
			
		else:
			
			logging.debug("creating new client")
			
			client=self.new_client()
			client['macs']=macs
			client['t_start']=time.time()
			client['t_last']=time.time()
			client['t_elapsed']=0
			client['dt_last']=0
			client['active']=1
			self.clients[sk]=client
			
			logging.debug("new client %s added"%sk)
			need_update=True
			
		
		if need_update==True:
			rval=self.update_firewall()
		
		self.clients[sk]['credits']=credits
		d['t_elapsed']=self.clients[sk]['t_elapsed']
		d['dt_last']=self.clients[sk]['dt_last']
		
		msg="returning dt_last=%d"%self.clients[sk]['dt_last']
		logging.debug(msg)
		
		return d
	
	def update_firewall(self):
		logging.debug("credit_meter_daemon.update_firewall")
		self.locktime=time.time()
		self.locked=True
		self.write_policy()
		dt=time.time()-self.locktime
		self.locked=False
		self.locktime=0
		return 1
		
	def write_policy(self):
		
		t0=time.time()
		msg="%d: begin write policy"%int(time.time()-t0)
		logging.debug(msg)
		
		common_cmds=[
			"iptables -F",
			"iptables -t nat -F",
			"iptables -P INPUT ACCEPT",
			"iptables -P OUTPUT ACCEPT",
			"iptables -P FORWARD DROP",
			"iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT",
			"iptables -I INPUT 1 -i wlan0 -j ACCEPT",
			"iptables -I INPUT 1 -i lo -j ACCEPT",
			"iptables -A INPUT -p UDP --dport bootps ! -i wlan0 -j REJECT",
			"iptables -A INPUT -p UDP --dport domain ! -i wlan0 -j REJECT",
			"iptables -A INPUT -p TCP ! -i wlan0 -d 0/0 --dport 0:1023 -j DROP",
			"iptables -A INPUT -p UDP ! -i wlan0 -d 0/0 --dport 0:1023 -j DROP",
		]
		
		
		wide_open=[
			"iptables -F",
			"iptables -t nat -F",
			"iptables -P INPUT ACCEPT",
			"iptables -P OUTPUT ACCEPT",
			"iptables -P FORWARD ACCEPT",
			"iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT",
			"iptables -I INPUT 1 -i wlan0 -j ACCEPT",
			"iptables -I INPUT 1 -i lo -j ACCEPT",
			"iptables -A INPUT -p UDP --dport bootps ! -i wlan0 -j REJECT",
			"iptables -A INPUT -p UDP --dport domain ! -i wlan0 -j REJECT",
			"iptables -A INPUT -p TCP ! -i wlan0 -d 0/0 --dport 0:1023 -j ACCEPT",
			"iptables -A INPUT -p UDP ! -i wlan0 -d 0/0 --dport 0:1023 -j ACCEPT",
		]
		vaio_only=[
			"iptables -A FORWARD  -m mac --mac-source 00:23:15:4b:5c:14 -j ACCEPT"
		]
		air_only=[
			"iptables -A FORWARD  -m mac --mac-source B8:E8:56:26:E4:B0 -j ACCEPT"
		]
		
		cmds=common_cmds
		
		if self.CREDIT_METER=="off":
			logging.debug("configuring for wide-open access")
			cmds=[]
			for cidx in range(len(wide_open)):
				cmds.append(wide_open[cidx])
		
		elif self.CREDIT_METER=="on":
			logging.debug("configuring for credit-metered access")
			for wm in self.wms:
				try:
					line="iptables -A FORWARD  -m mac --mac-source %s -j ACCEPT"%(wm)
					cmds.append(line)
				except Exception,e:
					msg="error writing whitelist_macs"
					event("error",msg,username="daemon")
					
			for wu in self.wus:
				try:
					line="iptables -A FORWARD  -p tcp -d %s --dport 80 -j ACCEPT"%(wu)
					cmds.append(line)
				except Exception,e:
					msg="error writing whitelist_urls"
					event("error",msg,username="daemon")
					
			
			for key in self.clients.keys():
				if not self.clients[key]['active']:continue
				#line="iptables -A FORWARD  -m mac --mac-source %s -j ACCEPT"%(key)
				#msg="%d: %s"%(int(time.time()-t0),line)
				#logging.debug(msg)
				#cmds.append(line)
				
				for mac in self.clients[key]['macs']:
					#if mac==key:continue
					line="iptables -A FORWARD  -m mac --mac-source %s -j ACCEPT"%(mac)
					msg="%d: %s"%(int(time.time()-t0),line)
					logging.debug(msg)
					cmds.append(line)

		else:
			logging.debug("UNRECOGNIZED credit meter mode")
				
		cmds.append("iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE")
		
		for cidx in range(len(cmds)):
			msg="%d %d: %s"%(int(time.time()-t0),cidx,cmds[cidx])
			logging.debug(msg)
			if not AM_DEMO:
				os.system(cmds[cidx])
		
		logging.debug('finished write_policy')
		
	def update_wus(self,wus):
		self.wus=wus
		logging.debug("wus updated")
		return 1
		
	def update_wms(self,wms):
		self.wms=wms
		logging.debug("wms updated")
		return 1
	
	def update_mode(self,mode):
		self.CREDIT_METER=mode
		msg="credit_meter_daemon.update_mode:%s"%mode
		logging.debug(msg)
		return 1
		
	def clients_status(self):
		logging.debug("credit_meter_daemon.clients_status")
		logging.debug(`self.clients`)
		return self.clients
	
	def run(self):
		
		self.RUNNING=True
		thread.start_new_thread(self.while_running,())
		logging.debug('bookeeping thread started')

		self.server=SimpleXMLRPCServer((get_rpc_hostname(),METER_SERVICE_PORT))
		self.server.register_introspection_functions()
		self.server.register_instance(self)
		self.server.serve_forever()



if __name__=="__main__":

	daemon=DaemonProcess('/var/run/credit_meter_daemon.pid')
	
	if len(sys.argv)==2:
		if 'start'==sys.argv[1]:
			daemon.start()
		elif 'stop'==sys.argv[1]:
			daemon.stop()
		elif 'restart'==sys.argv[1]:
			daemon.restart()
		elif 'status'==sys.argv[1]:
			if os.path.exists('/var/run/credit_meter_daemon.pid'):
				print 'running'
			else:
				print 'stopped'
				
		else:
			logging.debug("UNK")
			print "Unknown command"
			sys.exit(2)
		sys.exit(0)
	else:
		print "usage: %s start|stop|restart|status"%sys.argv[0]
		sys.exit(2)
