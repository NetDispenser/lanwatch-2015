#!/usr/bin/env python
from daemon import Daemon
#from service_utils import *
#from country_codes import *
#from ip_idns import *
import logging,json,time,sys,os,re,copy
from xmlrpc.server import SimpleXMLRPCServer
import threading
from queue import Queue

FORMAT = '%(message)s'
logging.basicConfig(filename='xtcpd.log',level=logging.DEBUG,format=FORMAT)
logging.disable(logging.DEBUG)

lock = threading.Lock()

import GeoIP
gip=GeoIP.open("/usr/share/GeoIP/GeoLiteCity.dat",GeoIP.GEOIP_STANDARD)

rexp=re.compile('(\d+:\d+:\d+)(\.\d+) (IP) (.*)(\.\d+) > (\d+\.\d+\.\d+\.\d+)(\.\d+)(.*)')

class DaemonProcess(Daemon):

	def __init__(self,pidfile):
		Daemon.__init__(self,pidfile)
		self.q = Queue()
		self.pcount=0
		self.create_count=0
		self.RUNNING=False
		self.DEBUG=False
		self.NUM_THREADS=5
		self.buffer=[]
		self.ips={}
		self.t=None

	def harvest(self):
		cmd="tcpdump -i eth0 -l -s 0 -n"
		p=os.popen(cmd)
		while True:
			if self.RUNNING:
				self.q.put(p.readline())
				for dummy in range(self.NUM_THREADS-threading.active_count()):
					logging.debug("creating thread")
					t=threading.Thread(target=self.process)
					t.daemon=True
					t.start()
					self.create_count+=1
			else:time.sleep(1)

	def process(self):
		while True:
			#with lock:
			try:
				item=self.q.get()
				a=rexp.match(item)
				if not a:continue
				else:self.pcount+=1
				src=a.group(4)
				sport=a.group(5)
				dst=a.group(6)
				dport=a.group(7)
				msg="%s %s -> %s %s"%(src,sport,dst,dport)
				logging.debug(msg)
				pval=gip.record_by_addr(dst)
				if not pval:continue
				try:pval['keys']=list(pval.keys())
				except:pass#b/c g(192.168) DNE
				pval["keys"].append("src")
				pval["keys"].append("sport")
				pval["keys"].append("dst")
				pval["keys"].append("dport")
				pval['src']=src
				pval['sport']=sport
				pval['dst']=dst
				pval['dport']=dport
				self.buffer.append(pval)
				#self.q.task_done()
			except:
				logging.exception("exception processing")

	def toggle_debug(self,*args):
		if not self.DEBUG:
			self.DEBUG=True
			logging.disable(logging.NOTSET)
		else:
			self.DEBUG=False
			logging.disable(logging.DEBUG)
		rval={'keys':['debug'],'debug':self.DEBUG}
		return json.dumps(rval)

	def toggle_running(self,*args):
		if not self.t:
			self.t = threading.Thread(target=self.harvest)
			self.t.daemon = True
			self.t.start()

		if not self.RUNNING:
			self.RUNNING=True
		else:
			self.RUNNING=False

		rval={'keys':['running'],'running':self.RUNNING}
		return json.dumps(rval)

	def get_data(self,*args):
		#logging.debug("get_data")
		self.t_last_call=time.time()

		rval={
			'keys':['time','qsize','pcount','create_count','running','debug','active','buffer'],
			'time':time.time(),
			'qsize':self.q.qsize(),
			'pcount':self.pcount,
			'create_count':self.create_count,
			'running':self.RUNNING,
			'active':threading.active_count(),
			'buffer':copy.copy(self.buffer),
			'debug':self.DEBUG,
		}
		self.buffer.__init__()
		return json.dumps(rval)

	def run(self):
		self.RUNNING=False
		self.server=SimpleXMLRPCServer(('localhost',8000))
		self.server.register_introspection_functions()
		self.server.register_function(self.toggle_debug)
		self.server.register_function(self.toggle_running)
		self.server.register_instance(self)
		self.server.serve_forever()

if __name__=="__main__":
	daemon=DaemonProcess('/var/run/xtcpd.pid')
	if len(sys.argv)==2:
		if 'start'==sys.argv[1]:
			daemon.start()
		elif 'stop'==sys.argv[1]:
			daemon.stop()
		elif 'restart'==sys.argv[1]:
			daemon.restart()
		elif 'status'==sys.argv[1]:
			if os.path.exists('/var/run/xtcpd.pid'):
				print('running')
			else:
				print('stopped')
		else:
			logging.debug("UNK")
			print("Unknown command")
			sys.exit(2)
		sys.exit(0)
	else:
		print("usage: %s start|stop|restart|status"%sys.argv[0])
		sys.exit(2)
