#!/usr/bin/env python
from daemon import Daemon

#NOTE:this is a daemon (outside django) so don't import with django's module path!
#DJANGO_LOG, RPC_HOSTNAME, MESSAGES_SERVICE_PORT, get_rpc_hostname(), 
from service_utils import *

FORMAT = '%(message)s'
logging.basicConfig(filename=DJANGO_LOG,level=logging.DEBUG,format=FORMAT)


class DaemonProcess(Daemon):
	"""
	First priority are conection messages, which we harvest in order to offer to
	user during setup, as an ease-of-use feature. We also handle the transient buffer
	of the TrafficWidget.  
	
	Design: when event of interest comes in we HTTP.GET a django url which effectively says 
	"messages_daemon has new data for you" , causing *django* to pull from known/single 
	source, and _not_ accepting query string of "data", as had previously planned.
	"""
	def __init__(self,pidfile):
		Daemon.__init__(self,pidfile)
		self.t_last_call=time.time()
		self.buffer=[]
		self.pckts=[]
		self.buffer_total=0
		self.pckts_total=0
		self.COLLECTING=False
		self.t_started=time.time()
		
	def get_data(self,*args):
		try:
			self.t_last_call=time.time()
			
			if not self.RUNNING:
				self.RUNNING=True
				logging.debug("messages_daemon self-starting")
				thread.start_new_thread(self.while_running,())
	
			rval=copy.copy(self.buffer)
			self.buffer.__init__()#resets list	
			
			return rval
		except Exception,e:
			logging.exception("Excepiton in messages_daemon.get_data")
			
	def get_status(self):
		try:
			uptime=time.time()-self.t_started
			
			status_line="messages: %d/%d, %d/%d"%(len(self.buffer),self.buffer_total,len(self.pckts),self.pckts_total)
			return status_line	
		except Exception,e:
			logging.exception("Exception in messages_daemon.get_status")
						
	def get_pckts(self,*args):
		try:
			#logging.debug("messages_daemon.get_pckts")
			
			rval=copy.copy(self.pckts)
			self.pckts.__init__()#resets list
			
			return rval
		except Exception,e:
			logging.exception("Exception in messages_daemon.get_pckts")
			
	def while_running(self,*args):
		try:
			cmd="tail -0f /var/log/messages"
			p=os.popen(cmd)
			self.t_last_call=time.time()
			
			while self.RUNNING:
				
				if self.t_last_call<time.time()-30:
					self.RUNNING=False
					logging.debug("messages_daemon self-stopping")
				
				line=p.readline()
				if string.find(line,'rt2800usb')>-1:continue
				
				tstamp=mktstamp()
				msg="%.02f,%s,%s,%s"%(time.time(),tstamp,"Messages",line)
				
				#Turning off so Msgs don't obscure Django msgs (these ones, which are the same)
				#self.buffer.append(msg)
				
			p.close()	
		except Exception,e:
			logging.exception("Exception in messages_daemon.while_running")	
	
	def messages_collector(self,*args):
		logging.debug("starting messages collector")
		services={
			'/etc/init.d/net.eth0':{
				'ERROR:':{'status':'eth0 error','fprint':{}}
			},
			'/etc/init.d/net.wlan0':{
				'ERROR:':{'status':'wlan0 error','fprint':{}}
			},
			'kernel':{},
			'dnsmasq-dhcp':{
				'DHCPRELEASE(wlan0)':{'status':'disconnected','fprint':{'ip':6,'mac':7}},
				'DHCPREQUEST(wlan0)':{'status':'DHCPREQUEST','fprint':{'ip':6,'mac':7}},
				'DHCPACK(wlan0)':{'status':'DHCPACK','fprint':{'ip':6,'mac':7,'device_name':8}},
				'DHCPDISCOVER(wlan0)':{'status':'DHCPDISCOVER','fprint':{'mac':6}},
				'DHCPOFFER(wlan0)':{'status':'DHCPOFFER','fprint':{'ip':6,'mac':7}},
				'DHCPINFORM(wlan0)':{'action':'DHCPINFORM','fprint':{'ip':6,'mac':7}},
			},
			'hostapd':{
				'deauthenticated':{'status':'disconnected','fprint':{'mac':7}},#
				'disassociated':{'status':'disconnected','fprint':{'mac':7}},#
				'authenticated':{'status':'authenticated','fprint':{'mac':7}},#awaiting correct passwd
				'associated':{'status':'associated','fprint':{'mac':7}},#awaiting correct passwd -> inactive
				'deauthenticated due to local deauth request':{'status':'disconnected','fprint':{'mac':7}},#hostapd password error
				'group key handshake completed':{'status':'handshake complete','fprint':{'mac':7}},#affirm still connected (every 10 min)
				'starting accounting session':{'status':'connected','fprint':{'mac':7}},#password correct, start session ->inactive
			},
			'sshd':{
				'Authname;Remote:':{'status':'remote auth request','fprint':{'ip':8,'username':9}},#ip needs extra removed following -
				'Connection closed by':{'status':'disconnected','fprint':{}},
				'Accepted keyboard-interactive/pam for':{'status':'accepted keyboard session','fprint':{'ip':10,'username':8,'port':12}},
				'session opened for user':{'status':'session opened','fprint':{'username':10}},
				'session closed for user':{'status':'session closed','fprint':{'username':10}},
				'Received disconnect from':{'status':'disconnected','fprint':{'ip':8,}},
			},
			'dnsmasq':{
				'using nameserver':{'status':'acquiring nameserver'},
				'no servers found in /etc/resolv.conf':{'status':'eth0 error','fprint':{}},#when eth0 unplugged
			},
			'login':{
				'ROOT LOGIN':{'status':'root','fprint':{}},
			}
		}
		
		#cmd="tail -0f /var/log/messages"
		cmd="tail -0f /var/log/syslog"
		logging.debug(cmd)
		p=os.popen(cmd)
		
		while self.COLLECTING:
			try:
				line=p.readline()
				logging.debug(line)
				fixline=string.replace(line,"  "," ")
				sline=string.split(fixline," ")
				service=sline[4]
				service=string.replace(service,":","")
				if service.count("[")>0:
					spid=string.split(service,'[',1)
					service=spid[0]
				
				if services.has_key(service):
					for key in services[service].keys():
						if line.count(key)>0:
							
							msg="service=%s key=%s"%(service,key)
							logging.debug(msg)
							
							pckt={'service':service}
							status=services[service][key]['status']
							if service=='dnsmasq-dhcp':status='connected'
							if service=='hostapd':
								status='connected'
								if key=='deauthenticated':status='disconnected'
								if key=='disassociated':status='disconnected'
								if key=='deauthenticated':status='disconnected'
							pckt['status']=status
							
							msg="service=%s  status=%s"%(service,status)
							for fkey in services[service][key]['fprint'].keys():
								item=string.strip( sline[ services[service][key]['fprint'][fkey] ] )
								if key=="Authname;Remote:" and fkey=="ip":
									if item.count("-")>0:item=string.split(item,"-")[0]
								if key=="Received disconnect from" and fkey=="ip":	
									if item.count(":")>0:item=string.split(item,":")[0]
								
								
								pckt[fkey]=item	
								msg="%s %s=%s"%(msg,fkey,item)
								#logging.debug(msg)
							
							#self.process_pckt(pckt)
							
							#logging.info(json.dumps(pckt))
							self.pckts.append(pckt)
							self.pckts_total+=1
							
							"""
							tstamp=mktstamp()
							msg="%.02f,%s,%s,%s"%(time.time(),tstamp,"Messages",line)
							self.buffer.append(msg)
							self.buffer_total+=1
							"""
							
							url="http://%s/services/ping"%(RPC_HOSTNAME)
							logging.debug(url)
							f=urllib2.urlopen(url)
							dummy=f.read(100)
							f.close()
							
			except Exception,e:
				logging.exception("exception in messages_collector")
				logging.debug("EXCEPTION IN MESSAGES COLLECTOR")
				logging.debug(line)
		
		p.close()
		logging.debug("exiting messages_collector")
		
	def run(self):
		
		self.RUNNING=False
		
		self.COLLECTING=True
		logging.debug("collection thread starting")
		thread.start_new_thread(self.messages_collector,())
		
		self.server=SimpleXMLRPCServer((get_rpc_hostname(),MESSAGES_SERVICE_PORT))
		self.server.register_introspection_functions()
		self.server.register_instance(self)
		self.server.serve_forever()



if __name__=="__main__":

	daemon=DaemonProcess('/var/run/messages_daemon.pid')
	
	if len(sys.argv)==2:
		if 'start'==sys.argv[1]:
			daemon.start()
		elif 'stop'==sys.argv[1]:
			daemon.stop()
		elif 'restart'==sys.argv[1]:
			daemon.restart()
		elif 'status'==sys.argv[1]:
			if os.path.exists('/var/run/messages_daemon.pid'):
				print 'running'
			else:
				print 'stopped'
				
		else:
			logging.debug("UNK")
			print "Unknown command"
			sys.exit(2)
		sys.exit(0)
	else:
		print "usage: %s start|stop|restart|status"%sys.argv[0]
		sys.exit(2)
