#!/usr/bin/env python
from daemon import Daemon
from service_utils import *
from country_codes import *
#from ip_idns import *
import logging,json

gip=None
if USE_PYGEOIP:
	import pygeoip
	gip=pygeoip.GeoIP("/usr/share/GeoIP/GeoLiteCity.dat")
else:
	import GeoIP
	gip=GeoIP.open("/usr/share/GeoIP/GeoLiteCity.dat",GeoIP.GEOIP_STANDARD)


FORMAT = '%(message)s'
logging.basicConfig(filename=TCP_LOG,level=logging.INFO,format=FORMAT)

#13:34:18.556110 IP 192.168.66.166.49963 > 208.111.39.47.http: Flags [P.], seq 3153:3679, ack 1029, win 8192, options [nop,nop,TS val 655284177 ecr 109486646], length 526
#rexp=re.compile('(\d+:\d+:\d+)(\.\d+) (IP) (.*)(\.\d+) > (\d+\.\d+\.\d+\.\d+)(\.\d\:)(.*)')#(.*)#


#The following tcpdump command produce the next following output (among other) ... so want rexp for this line:
#tcpdump -i eth0 -l -s 0 -nn not src net 70.210 and not dst net 70.210|grep  208.111.39.69
#13:46:51.841958 IP 66.249.67.78.49772 > 208.111.39.69.80: Flags [.], ack 5673, win 424, options [nop,nop,TS val 2125410414 ecr 839918059], length 0
rexp=re.compile('(\d+:\d+:\d+)(\.\d+) (IP) (.*)(\.\d+) > (\d+\.\d+\.\d+\.\d+)(\.\d+)(.*)')

ipfname="ip_idns.dat"
ipf=open(ipfname)
IP_IDNS=json.loads(ipf.read())
ipf.close()
logging.debug('IP_IDNS loaded:'+`IP_IDNS`+" "+`type(IP_IDNS)`)

class DaemonProcess(Daemon):
	"""
	The written record: /tmp/tcp_daemon.log handles the long-term record.
	The buffered record is for plotting on timeline.
	This service should also do long-term buffer of (arb) events above (arb) threshold.
	"""
	def __init__(self,pidfile):
		Daemon.__init__(self,pidfile)
		self.buffer=[]
		self.ips={}
		#cmd="tcpdump -i %s -l -s 0 -A -qt 'tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420'"%(INTERFACE)
		#cmd="tcpdump -i %s -l -s 0 -A -nn not dst net 192.168.66 and tcp and port 80 and  and tcp[13]==2"%(INTERFACE)
		#cmd="tcpdump -i %s -l -s 0 -nn not dst net 192.168.66"%(INTERFACE)#udp video data (mucho data!)

		#cmd="tcpdump -i %s -l -s 0 -nn not dst net 208.111.39.69"%(INTERFACE)#udp video data (mucho data!)
		cmd="tcpdump -i eth0 -l -s 0 -n"#not src net 70.210 and not dst net 70.210|grep  39.69"

		self.tcpdump_cmd=cmd
		self.t_last_call=time.time()
		self.RUNNING=False

	def get_geoip(self,*args):
		#logging.debug("get_geoip")
		rval=copy.copy(self.ips)
		rval['keys']=rval.keys()

		logging.debug(rval)
		logging.debug(" ")

		self.ips={}
		return rval

	def get_data(self,*args):

		#logging.debug("get_data")

		self.t_last_call=time.time()

		if not self.RUNNING:
			self.RUNNING=True
			logging.debug("tcp_daemon self-starting")
			thread.start_new_thread(self.while_running,())

		"""
		assume only 1 client and clear data each time requested
		"""
		rval=copy.copy(self.buffer)

		if AM_DEMO:
			pass
		else:
			self.buffer.__init__()

		return rval

	def get_tcpdump_cmd(self):
		return self.tcpdump_cmd

	def get_buffer_length(self):
		return len(self.buffer)

	def while_running(self,*args):

		logging.debug(self.tcpdump_cmd)
		p=os.popen(self.tcpdump_cmd)

		tstamp=''

		while self.RUNNING:
			if self.t_last_call<time.time()-30:
				self.RUNNING=False
				logging.debug("tcp_daemon self-stopping")

			line=p.readline()
			logging.debug(line)

			a=rexp.match(line)
			if not a:
				logging.debug("NO MATCH")
				continue
			else:
				logging.debug("Match")
				pass

			tstamp=mktstamp()

			src=a.group(4)
			if src=='0.0.0.0':continue

			amsg="a="
			for aidx in range(1,12):
				try:amsg+=a.group(aidx)+" "
				except:pass
			logging.debug(amsg)

			#function at service_utils.py but refers to gentoo router.  demo mode had hard coded leases.
			#this iteration just skipping altogether for simplicity.
			#src=get_best_name(src)

			dest=a.group(6)
			#dest="0.0.0.0"
			
			src_port=a.group(5)
			dest_port=a.group(7)
			
			try:
				logging.debug("checking for dest: "+dest)
				if not IP_IDNS.has_key(dest):
					logging.debug("adding dest")
					logging.debug(IP_IDNS['last_idn'])
					IP_IDNS["last_idn"]+=1
					logging.debug(IP_IDNS['last_idn'])
					logging.debug("last_idn="+`IP_IDNS['last_idn']`)
					IP_IDNS[dest]=IP_IDNS['last_idn']
					logging.debug("added :"+dest+" as IP_IDNS IDN="+`IP_IDNS[dest]`)
				
				logging.debug("checking for src: "+src)
				if not IP_IDNS.has_key(src):
					logging.debug("adding src")
					IP_IDNS["last_idn"]+=1
					IP_IDNS[src]=IP_IDNS["last_idn"]
					logging.debug("added :"+src+" as IP_IDNS IDN="+`IP_IDNS[src]`)
			
			except Exception,e:
				logging.exception("AYE!")
			
			try:
				if not self.ips.has_key(dest):

					gkeys=None
					if USE_PYGEOIP:
						gkeys=['city','region_code','area_code','time_zone','dma_code','metro_code','country_code3','latitude','postal_code','longitude','country_code','country_name','continent']
					else:
						gkeys=['city','region_name','area_code','time_zone','metro_code','country_code3','latitude','postal_code','longitude','country_code','country_name']

					logging.debug("adding "+dest)
					g=gip.record_by_addr(dest)
					if not g:
						if dest=='10.0.0.13':
							self.ips[dest]={
								'keys':gkeys,
								'src':src,
								'dest':dest,
								'src_port':src_port,
								'dest_port':dest_port,
								'idn_country':'US',
								'ip_idn':0,
								'city':'Beaverton',
								'region_name':'Oregon',
								'area_code':503,
								'time_zone':'Pacific',
								'latitude':45.4871,
								'longitude':-122.803,
								'country_code':232,
								'country_name':'United States',
							}

						else:
							logging.debug("skipping: "+dest)
						continue


					self.ips[dest]={
						'keys':gkeys,
						'src':src,
						'dest':dest,
						'src_port':src_port,
						'dest_port':dest_port,
						'idn_country':COUNTRY_CODES[g['country_code']],
						'ip_idn':IP_IDNS[dest],
					}
					for gidx in range(len(gkeys)):
						gkey=gkeys[gidx]
						gval=g[gkey]
						if not gval:
							logging.debug("failed to get "+gkey)
							gval=""
						self.ips[dest][gkey]=gval

					logging.debug(self.ips[dest])

			except Exception,e:
				logging.exception("exception getting geoip info")
				logging.debug(dest)

			msg="%.02f,%s,%s,%s,%s,%s"%(time.time(),tstamp,src,dest,src_port,dest_port)
			logging.debug(msg)
			self.buffer.append(msg)

			#scenerio: nobody's expired,large buffer, then trickle of traffic and only removing 10x per matched line
			#i.e. not clearing out fast enough ... hence dangerous while loop:
			while True:
				try:
					x=eval(string.split(self.buffer[0],",")[0])
					t_min=time.time()-BUFFSIZE
					if x<t_min:
						self.buffer.pop(0)
					else:break
				except Exception,e:
					logging.exception("exception clearing tcp buffer")
					break

	def run(self):

		self.RUNNING=False

		self.server=SimpleXMLRPCServer((get_rpc_hostname(),TCP_SERVICE_PORT))
		self.server.register_introspection_functions()
		self.server.register_instance(self)
		self.server.serve_forever()



if __name__=="__main__":

	daemon=DaemonProcess('/var/run/tcp_daemon.pid')

	if len(sys.argv)==2:
		if 'start'==sys.argv[1]:
			daemon.start()
		elif 'stop'==sys.argv[1]:
			daemon.stop()
		elif 'restart'==sys.argv[1]:
			daemon.restart()
		elif 'status'==sys.argv[1]:
			if os.path.exists('/var/run/tcp_daemon.pid'):
				print 'running'
			else:
				print 'stopped'

		else:
			logging.debug("UNK")
			print "Unknown command"
			sys.exit(2)
		sys.exit(0)
	else:
		print "usage: %s start|stop|restart|status"%sys.argv[0]
		sys.exit(2)
